<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Routine name="CPM" type="MAC" languagemode="0"><![CDATA[
#include CPM.License
#include %occInclude
#include CPM.LIB
#include CPM.DataTypes

SHELL
    new
    #; here goes interactive entry
    #; aliases for commands
    do ALIASES(.aliases)
    for i=1:1 {
        set line=$text(ALIASES+i)
        quit:$extract(line)'=" "
        set command=$zstrip($piece(line,";",2),"<>WCP")
        for j=3:1:$length(line,";") {
            set alias=$zconvert($piece(line,";",j),"U")
            continue:alias=""
            continue:$data(aliases(alias))
            set aliases(alias)=command
        }
    }
    for {
        write !,"CPM:"_$Namespace_">> "
        read line
        do ExtractArgs(.line, .command, .args)
        
        continue:command=""
        set command=$zconvert(command,"U")
        if $data(aliases(command),command)
        
        quit:command="QUIT"
        
        do BATCH(command, args...)
    }
    quit

ExtractArgs(&line,&command,&args) {
    #dim pattern As %String = ##class(%Regex.Matcher).%New("[^ ]+|\""([^\""]+)\""")

    set line    = $zstrip(line,"<>WC")
    set command = $piece(line," ")
    set line    = $piece(line," ",2,*)

    kill args
    set args = 0
    set pattern.Text = line
    while pattern.Locate() {
        set argument = pattern.Group
        set args($increment(args)) = $zstrip(argument, "<>", """")
    }
}

#define OptionBoolean 1
#define OptionString 2

/// GetOptions(.args,"-o",.option,"/verbose|/v",.verbose,"/include:",.include)
GetOptions(&args,&fmtDest...) public {
    #dim known ; known options

    // 1. scan options
    for i=1:2:$get(fmtDest) {
        #dim opts As %String = $get(fmtDest(i))
        continue:opts=""
        for j=1:1:$length(opts,"|") {
            #dim opt As %String = $zstrip($piece(opts,"|",j), "<>", "-/")
            #dim lastC As %String = $e(opt,*)
            #dim optType As %Integer = $case(lastC, ":":$$$OptionString, :$$$OptionBoolean)
            set opt = $zstrip(opt,"<>",":")
            
            set known(opt) = $lb(optType, i + 1) ; remember option type and destination argument pointer
        }
    }
    
    #dim argsN = "" ; new args without processed known options
    // 2. process passed args while creating new modified args (without known /options)
    for i=1:1:$get(args) {
        #dim arg As %String = $get(args(i))
        #dim isOption As %Boolean = $case($extract(arg,1),"/":1, "-":1, :0)

        if isOption {
            #dim optInfo = $get(known($zstrip(arg, "<>", "-/:")))

            if $length(optInfo)>0 {
                #dim type As %Integer = $li(optInfo,1)
                #dim index As %Integer = $li(optInfo,2)
                if type=$$$OptionBoolean {
                    set fmtDest(index) = 1
                } else {
                    set fmtDest(index) = $get(args($i(i)))
                }
            } else {
                return i ; unknown /option - bails out
            }
        } else {
            set argsN($i(argsN)) = arg
        }
    }
    // 3. save not consumed arguments back to args array
    if $get(argsN)<$get(args) {
        kill args merge args = argsN
    }
    quit 0
}
BATCH(command="help", args...)
    ; here goes batch entry
    do ALIASES(.aliases)
    set command=$zconvert(command,"U")
    if $data(aliases(command),command)
    
    if $text(@command)="" {
        write !,"Unrecognized command: ",command,!
        quit
    }
    try {
        set command=command_"(args...)"
        do @command
    } catch {
        write !,"Error occured: ",$zerror
    }
    quit

ALIASES(aliases)
 ;QUIT;Q
 ;INSTALL;I
 ;HELP;?
 ;LIST;L
#; aliases for commands
    new (aliases)
    for i=1:1 {
        set line=$text(ALIASES+i)
        quit:$extract(line)'=" "
        set command=$zstrip($piece(line,";",2),"<>WCP")
        for j=3:1:$length(line,";") {
            set alias=$zconvert($piece(line,";",j),"U")
            continue:alias=""
            continue:$data(aliases(alias))
            set aliases(alias)=command
        }
    }
    quit
COMMANDS

RegisterAllSourceTypes() {
    do ##class(CPM.Source.IBase).UnregisterExts()
    do ##class(CPM.Source.IBase).ForEachSuccessor("RegisterExts")
}
INSTALL(packages...) ;;install package
    new (packages)
    if '$data(packages) {
        write !,"Nothing to install"
        quit
    }
    do RegisterAllSourceTypes()
    write !,"Installing packages: "
    for i=1:1:packages {
        #dim package As %String = packages(i)
        #dim packageFile As CPM.Source.IBase = ##class(CPM.Source.IBase).%OpenContainer(package)
        if '$isobject(packageFile) {
            continue
        }
        if packageFile.IsPacked {
            do packageFile.Unpack()
        }
        #dim packageData As CPM.IPackage = packageFile.Parse()
        write !?3, packageData.Name, ?25, packageData.Version, ?45, packageData.Description,!,packageData.Path,!
        do packageFile.Install(packageData)
    }
    quit

#define LastPkgName ^||CPM.LastPkgName

PACKAGE(args...) ;;package creation commands
    new (args)
    #dim debug As %Boolean = 0
    #dim create As %Boolean = 0
    #dim prjName As %String = ""
    #dim pkgAuthor As %String = ""
    #dim pkgDescription As %String = ""
    #dim pkgLicense As %String = ""
    #dim pkgVersion As %String = ""
    
    do GetOptions(.args, 
                  "/debug", .debug,
                  "/c|/create", .create, "/prj:|/from:", .prjName,
                  "/author:", .pkgAuthor, "/description:", .pkgDescription,
                  "/license:", .pkgLicense, "/version:", .pkgVersion)

    #dim pkgName As %String = ""
    #dim status As %Status = $$$OK
    
    if create {
        set pkgName = $$$PopArrValue(args)
        set $$$LastPkgName = pkgName
    } else {
        set pkgName = $$$LastPkgName
    }
    #dim p As CPM.Registry.Package = ##class(CPM.Registry.Package).CreateOrOpenId(pkgName)
    $$$THROWONERROR(status,$isobject(p))
    
#define SetIf(%val,%init) if %init'="" { set %val = %init }

    $$$SetIf(p.Author,pkgAuthor)
    $$$SetIf(p.Description,pkgDescription)
    $$$SetIf(p.License,pkgLicense)
    $$$SetIf(p.Version,pkgVersion)
    
    // link package to the project content
    if prjName '= "" {
        #dim prj As %Studio.Project = ##class(%Studio.Project).%OpenId(prjName)
    }
    if debug { zw p }
    do p.%Save()

    quit
    


SEARCH(string, args...) ;;search packages
    set cpm=##class(CPM.Main).%New()
    do cpm.Search(string)
    quit
    

LIST(args...) ;;list of installed packages
    new (args)
    #dim verbose As %Boolean = 0
    do GetOptions(.args, "/v|/verbose", .verbose)

    set sql=##class(%SQL.Statement).%New()
    set tSC=sql.%Prepare("SELECT %ID, Name, Version, Description FROM CPM_Registry.Package")
    quit:'$$$ISOK(tSC)
    set tRS=sql.%Execute()
    while tRS.%Next() {
        write !?3,tRS.Name,?32,tRS.Version,?42,tRS.Description
        if verbose {
            #dim o As CPM.Registry.Package = ##class(CPM.Registry.Package).%OpenId(tRS.ID)
            #dim items As array of %String = o.Items
            #dim key As %String = ""
            for  {
                set key = items.Next(key) quit:key=""
                write ?10,key,!
            }
        }
    }
    quit

HELP(args...) ;;this help
    new (args)
    write !,"Cache Package Manager"
    write !!,"Available commands:"
    for i=1:1 {
        set line=$text(COMMANDS+i)
        quit:line=""

        continue:$zstrip($extract(line),"*WCP")=""
        set help=$piece(line,";;",2)
        continue:help=""
        set command=$zconvert($piece(line,"("),"L")
        write !?3,command,?15,help
    }
    write !?3,"quit",?15,"quit from shell"
    write !
    quit
    

]]></Routine>
</Export>
