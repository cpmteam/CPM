<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Routine name="CPM" type="MAC" languagemode="0"><![CDATA[
#include CPM.License
#include %occInclude
#include CPM.LIB
#include CPM.DataTypes

SHELL
    new
    #; here goes interactive entry
    #; aliases for commands
    do ALIASES(.aliases)
    for i=1:1 {
        set line=$text(ALIASES+i)
        quit:$extract(line)'=" "
        set command=$zstrip($piece(line,";",2),"<>WCP")
        for j=3:1:$length(line,";") {
            set alias=$zconvert($piece(line,";",j),"U")
            continue:alias=""
            continue:$data(aliases(alias))
            set aliases(alias)=command
        }
    }
    for {
        write !,"CPM:"_$Namespace_">> "
        read line
        do ExtractArgs(.line, .command, .args)
        
        continue:command=""
        set command=$zconvert(command,"U")
        if $data(aliases(command),command)
        
        quit:command="QUIT"
        
        do BATCH(command, args...)
    }
    quit

ExtractArgs(&line,&command,&args) {
    #dim pattern As %String = ##class(%Regex.Matcher).%New("[^ ]+|\""([^\""]+)\""")

    set line    = $zstrip(line,"<>WC")
    set command = $piece(line," ")
    set line    = $piece(line," ",2,*)

    kill args
    set args = 0
    set pattern.Text = line
    while pattern.Locate() {
        set argument = pattern.Group
        set args($increment(args)) = $zstrip(argument, "<>", """")
    }
}

#define OptionBoolean 1
#define OptionString 2

/// GetOptions(.args,"-o",.option,"/verbose|/v",.verbose,"/include:",.include)
GetOptions(&args,&fmtDest...) public {
    #dim known ; known options

    // 1. scan options
    for i=1:2:$get(fmtDest) {
        #dim opts As %String = $get(fmtDest(i))
        continue:opts=""
        for j=1:1:$length(opts,"|") {
            #dim opt As %String = $zstrip($piece(opts,"|",j), "<>", "-/")
            #dim lastC As %String = $e(opt,*)
            #dim optType As %Integer = $case(lastC, ":":$$$OptionString, :$$$OptionBoolean)
            set opt = $zstrip(opt,"<>",":")
            
            set known(opt) = $lb(optType, i + 1) ; remember option type and destination argument pointer
        }
    }
    
    #dim argsN = "" ; new args without processed known options
    // 2. process passed args while creating new modified args (without known /options)
    for i=1:1:$get(args) {
        #dim arg As %String = $get(args(i))
        #dim isOption As %Boolean = $case($extract(arg,1),"/":1, "-":1, :0)

        if isOption {
            #dim optInfo = $get(known($zstrip(arg, "<>", "-/:")))

            if $length(optInfo)>0 {
                #dim type As %Integer = $li(optInfo,1)
                #dim index As %Integer = $li(optInfo,2)
                if type=$$$OptionBoolean {
                    set fmtDest(index) = 1
                } else {
                    set fmtDest(index) = $get(args($i(i)))
                }
            } else {
                return i ; unknown /option - bails out
            }
        } else {
            set argsN($i(argsN)) = arg
        }
    }
    // 3. save not consumed arguments back to args array
    if $get(argsN)<$get(args) {
        kill args merge args = argsN
    }
    quit 0
}
PopArrValue(&args)
{
    #dim value 
    #dim key As %String = $order(args(""),1,value)
    quit:key=""
    if $data(args(key)) {
        kill args(key)
        return value
    }
    return ""
}

BATCH(command="help", args...)
    ; here goes batch entry
    do ALIASES(.aliases)
    set command=$zconvert(command,"U")
    if $data(aliases(command),command)
    
    if $text(@command)="" {
        write !,"Unrecognized command: ",command,!
        quit
    }
    try {
        set command=command_"(args...)"
        do @command
    } catch {
        write !,"Error occured: ",$zerror
    }
    quit

ALIASES(aliases)
 ;QUIT;Q
 ;INSTALL;INS;I
 ;HELP;?
 ;LIST;LIS;LS;L
 ;EXPORT;EXP;EX;E
#; aliases for commands
    new (aliases)
    for i=1:1 {
        set line=$text(ALIASES+i)
        quit:$extract(line)'=" "
        set command=$zstrip($piece(line,";",2),"<>WCP")
        for j=3:1:$length(line,";") {
            set alias=$zconvert($piece(line,";",j),"U")
            continue:alias=""
            continue:$data(aliases(alias))
            set aliases(alias)=command
        }
    }
    quit
COMMANDS

RegisterAllSourceTypes() {
    do ##class(CPM.Source.IBase).UnregisterExts()
    do ##class(CPM.Source.IBase).ForEachSuccessor("RegisterExts")
}
INSTALL(packages...) ;;install package
    do RegisterAllSourceTypes()
#if 1
    do $$$CpmInstance.Install(packages...)
    quit
#else
    new (packages)
    if '$data(packages) {
        write !,"Nothing to install"
        quit
    }
    write !,"Installing packages: "
    for i=1:1:packages {
        #dim package As %String = packages(i)
        #dim packageFile As CPM.Source.IBase = ##class(CPM.Source.IBase).%OpenContainer(package)
        if '$isobject(packageFile) {
            continue
        }
        if packageFile.IsPacked {
            do packageFile.Unpack()
        }
        #dim packageData As CPM.IPackage = packageFile.Parse()
        write !?3, packageData.name, ?25, packageData.version, ?45, packageData.description,!,packageData.path,!
        do packageFile.Install(packageData)
    }
#endif
    quit

PACKAGE(args...) ;;package creation commands
    new (args)
    #dim debug As %Boolean = 0
    #dim create As %Boolean = 0
    #dim prjName As %String = ""
    #dim pkgAuthor As %String = ""
    #dim pkgDescription As %String = ""
    #dim pkgLicense As %String = ""
    #dim pkgVersion As %String = ""
    
    do GetOptions(.args, 
                  "/debug", .debug,
                  "/c|/create", .create, "/prj:|/from:", .prjName,
                  "/author:", .pkgAuthor, "/description:", .pkgDescription,
                  "/license:", .pkgLicense, "/version:", .pkgVersion)

    #dim pkgName As %String = ""
    #dim status As %Status = $$$OK
    
    if create {
        set pkgName = $$PopArrValue(.args)
        set $$$CpmLastPkgName = pkgName
    } else {
        set pkgName = $$$CpmLastPkgName
    }
    #dim p As CPM.Registry.Package = ##class(CPM.Registry.Package).CreateOrOpenId(pkgName)
    $$$THROWONERROR(status,$isobject(p))
    
#define SetIf(%val,%init) if %init'="" { set %val = %init }

    $$$SetIf(p.author,pkgAuthor)
    $$$SetIf(p.description,pkgDescription)
    $$$SetIf(p.license,pkgLicense)
    $$$SetIf(p.version,pkgVersion)
    
    // link package to the project content
    if prjName '= "" {
        #dim prj As %Studio.Project = ##class(%Studio.Project).%OpenId(prjName)
    }
    if debug { zw p }
    do p.%Save()

    quit

EXPORT(args...) ;; prepare to publish - export package(s)
    new (args)
    #dim verbose As %Boolean = 0
    do GetOptions(.args, "/v|/verbose", .verbose)
    for i=1:1:$get(args) {
        #dim packageName As %String = $get(args(i))
        continue:packageName=""
        
        #dim p As CPM.Registry.Package = ##class(CPM.Registry.Package).%OpenId(packageName)
        if $isobject(p) {
            do p.Export(verbose)
        }
    }
    quit

SEARCH(terms...) ;;search packages
    do $$$CpmInstance.Search(terms...)
    quit

LIST(args...) ;;list of installed packages
    new (args)
    #dim verbose As %Boolean = 0
    #dim local As %Boolean = 1
    #dim remote As %Boolean = 0
    do GetOptions(.args, "/v|/verbose", .verbose, "/local", .local, "/remote", .remote)

    #dim sql As %SQL.Statement = ##class(%SQL.Statement).%New()
    #dim tSC As %Status = sql.%Prepare("SELECT %ID, Name, Version, Description FROM CPM_Registry.Package")
    quit:'$$$ISOK(tSC)

    #dim tRS As %SQL.StatementResult = sql.%Execute()
    while tRS.%Next() {
        write !?3,tRS.Name, ?32,tRS.Version, ?42,tRS.Description
        if verbose {
            #dim o As CPM.Registry.Package = ##class(CPM.Registry.Package).%OpenId(tRS.ID)
            #dim items As list of %String = o.items
            #dim i As %Integer
            for i=1:1:items.Count() {
                write !,?10,items.GetAt(i)
            }
            write !
        }
    }
    quit

CONFIG(args...) ;; get/set configuration parameters
    new (args)
    #dim debug As %Boolean = 0
    #dim getOp As %Boolean = 0
    #dim setOp As %Boolean = 0
    do GetOptions(.args, "/g|/get", .getOp, "/s|/set", .setOp, "/debug", .debug)

    #dim nameParam As %String = ""
    #dim valueParam As %String = ""
    
    if getOp {
        set nameParam  = $$PopArrValue(.args)
        write !,nameParam, ?14, " = ", $property( $$$CpmConfig, nameParam)
    }
    if setOp {
        set nameParam  = $$PopArrValue(.args)
        set valueParam = $$PopArrValue(.args)
        set $property($$$CpmConfig, nameParam) = valueParam
        write !,nameParam, ?14, " = ", $property( $$$CpmConfig, nameParam)
    }
    if 'getOp && 'setOp {
        // TODO - show whole configuration
    } 
    if debug { zw }
    quit

HELP(command="",args...) ;;this help
    new (command,args)
    if command'="" {
        set cpm=##class(CPM.Main).%New()
        do cpm.Help(command,args...)
        quit 
    }
    write !,"Cache Package Manager"
    write !!,"Available commands:"
    for i=1:1 {
        set line=$text(COMMANDS+i)
        quit:line=""

        continue:$zstrip($extract(line),"*WCP")=""
        set help=$piece(line,";;",2)
        continue:help=""
        set command=$zconvert($piece(line,"("),"L")
        write !?3,command,?15,help
    }
    write !?3,"quit",?15,"quit from shell"
    write !
    quit
    

]]></Routine>
</Export>
