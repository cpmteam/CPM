<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Routine name="CPM.MetaInfo" type="MAC" languagemode="0"><![CDATA[
#include CPM.License
#include CPM.DataTypes

ProcessManifest(FileName,&pkg,&deps,Debug=0) [xmltree] {
#if 0
    new xmltree
    do ##class(CPM.Utils.XmlArray).ArrayFromXml(FileName, $name(xmltree))
    merge pkg       = xmltree("Manifest", 1, "Package")
    merge localdeps = xmltree("Manifest", 2, "Dependencies")

    if Debug { write pkg("Name"),":",! }

    // FIXME - simpler for 1:1:deps?
    set i = $order(localdeps(""))
    while i'="" {
        #dim name As %String = localdeps(i,"Dependency","Name")

        set deps(name) = $get(localdeps(i,"Dependency","Version"),
                              $get(localdeps(i,"Dependency","Path"))) ; create exportable list of deps

        if Debug {
            write ?4, name, ?20, deps(name), !
        }
        set i = $order(localdeps(i))
    }
    if Debug { zw xmltree }
#else
    #dim parser As CPM.Source.Xml = ##class(CPM.Source.Xml).%New()
    set parser.DebugMode = Debug
    do parser.Open(FileName)
    #dim package As CPM.Source.IBase = parser.Parse()
    if Debug {
        write ?4, package.Name, ?20, package.Dependencies.Count(), !
    }
#endif
}

CreateManifestPath(rootdir,package) public {
    if '$data(package) || (package="") {
        quit ""
    }
    #dim dir As %String = ##class(%Library.File).NormalizeDirectory(package,rootdir)
    quit ##class(%Library.File).NormalizeFilename("manifest.xml",dir)
}

/// dump dependencies, optionally recursive and by request with whole xml tree
DumpDeps(FileName,Recursive=0,Debug=0) [queue,known] public {
    #dim directory As %String = ##class(%Library.File).GetDirectory(FileName)
    #dim rootdir As %String = ##class(%Library.File).ParentDirectoryName(directory)
    
    new queue, known
    $$$INITQUEUE(queue) $$$ENQUEUE(queue,"*")
    
    #dim i As %String
    #dim pkg, deps
    
    do {
        $$$DEQUEUE(queue)
        kill pkg, deps
        do ProcessManifest(FileName, .pkg, .deps, Debug)
        #dim pkgName As %String = pkg("Name")

        set known(pkgName) = 1 ; mark itself as visited
        
        #dim name As %String = $order(deps(""))
        while name '="" {
            if '$data(known(name)) {
                $$$ENQUEUE(queue,name)
                set known(name) = 1
            }
            set name = $order(deps(name))
        }
        set FileName = $$CreateManifestPath(rootdir, $$$QUEUEHEAD(queue))
    } while Recursive && $$$QUEUELEN(queue)
}

Dump(FileName) public {
    // TODO - convert XML to multidimensional array, then use it elsewhere
    #dim XmlParser As %XML.TextReader
    do ##class(%XML.TextReader).ParseFile(FileName,.XmlParser)
    while XmlParser.Read() {
        write XmlParser.NodeType, ?20, XmlParser.Name, ?32, XmlParser.Value,!
        for i=1:1:XmlParser.AttributeCount {
            do XmlParser.MoveToAttributeIndex(i)
            write ?8, XmlParser.NodeType, ?20, XmlParser.Name, ?32, XmlParser.Value,!
        }
    }
}

 
]]></Routine>
</Export>
